import{_ as o,r as l,o as r,c as u,a,e as n,w as t,b as s,d as c}from"./app-a153c100.js";const d="/MyBlog/assets/image-20210713202807818-9441f253.png",g="/MyBlog/assets/image-20210713203124797-f9da97ec.png",m="/MyBlog/assets/image-20210713203753373-b7f423ef.png",k="/MyBlog/assets/image-20210713204155887-ee278fdc.png",v="/MyBlog/assets/image-20210713205003790-228ec241.png",h="/MyBlog/assets/image-20210713210800950-bab8818b.png",_="/MyBlog/assets/image-20210713211009593-ae47b250.png",b="/MyBlog/assets/image-20210713211417049-047ba7cc.png",y="/MyBlog/assets/image-20210713211550169-cc6819c4.png",f="/MyBlog/assets/image-20210713211657319-80ac64a8.png",x="/MyBlog/assets/image-20210713211814094-a93dab09.png",B="/MyBlog/assets/image-20210713212656887-a0eaffc3.png",M="/MyBlog/assets/image-20210713212349272-3007dec3.png",R="/MyBlog/assets/image-20210713212336185-ddc95880.png",S="/MyBlog/assets/image-20210713212513324-28fb164b.png",I="/MyBlog/assets/image-20210713220736408-770dcf93.png",w="/MyBlog/assets/image-20210713212749575-e0d88df2.png",A="/MyBlog/assets/image-20210713212901725-88792b4f.png",C="/MyBlog/assets/image-20210713213146089-2d85f748.png",N="/MyBlog/assets/image-20210713213213075-55e93d00.png",E="/MyBlog/assets/image-20210713213312278-c05ae384.png",q="/MyBlog/assets/image-20210713213959569-1329e80b.png",L="/MyBlog/assets/image-20210713214404481-dd58b0b4.png",O="/MyBlog/assets/image-20210713214925388-b1743379.png",T="/MyBlog/assets/image-20210713220104956-12121acf.png",Z="/MyBlog/assets/image-20210713220509769-65068a67.png",j="/MyBlog/assets/image-20210713220605881-4a5c0ae8.png",D="/MyBlog/assets/image-20210713220857396-1a6601b4.png",H="/MyBlog/assets/image-20210713221339022-af41d8b9.png",U="/MyBlog/assets/image-20210713222157190-7fff9f5d.png",F="/MyBlog/assets/image-20210713222656562-ef35d9f6.png",V="/MyBlog/assets/image-20210713222757702-ebc9cc98.png",P="/MyBlog/assets/image-20210713222841951-45d22f54.png",J="/MyBlog/assets/image-20210713223041491-8e5fbe7d.png",K="/MyBlog/assets/image-20210713223150650-f1f29ad7.png",W="/MyBlog/assets/image-20210713224049419-829c2ccb.png",z="/MyBlog/assets/image-20210713224245731-568aa982.png",G="/MyBlog/assets/image-20210713224517686-42ff231f.png",Q="/MyBlog/assets/1525620483637-e890901b.png",X="/MyBlog/assets/1525620787090-b282c894.png",i="/MyBlog/assets/1525620835911-68010d3d.png",Y="/MyBlog/assets/1544361421671-716a80cf.png",$="/MyBlog/assets/1525622652849-27d60628.png",aa="/MyBlog/assets/1525622699666-91243812.png",sa="/MyBlog/assets/1525622754316-7d9042b3.png",na="/MyBlog/assets/image-20210713224724673-7bd19140.png",ea="/MyBlog/assets/image-20210713225653000-6a1b8491.png",ta="/MyBlog/assets/image-20210713230444308-dc48d566.png",pa="/MyBlog/assets/image-20210713231439607-8ac53342.png",la="/MyBlog/assets/image-20210713232522531-a62668e4.png",ia="/MyBlog/assets/image-20210713232658928-ef2e2e0e.png",ca="/MyBlog/assets/image-20210713232916215-4648b223.png",oa="/MyBlog/assets/image-20210713233528982-1db3e786.png",ra="/MyBlog/assets/image-20210713233727923-c7a3140c.png",ua="/MyBlog/assets/image-20210713235133225-53c68e3b.png",da="/MyBlog/assets/image-20210713235235219-c1f68d9c.png",ga="/MyBlog/assets/image-20210714000101516-40beadff.png",ma="/MyBlog/assets/image-20210714000414781-fc6ca280.png",ka="/MyBlog/assets/image-20210714000440143-44fd2ac2.png",va="/MyBlog/assets/image-20210714000505928-65ded151.png",ha="/MyBlog/assets/image-20210714000522913-7d614234.png",_a="/MyBlog/assets/image-20210714000830703-2ca6ce38.png",ba="/MyBlog/assets/image-20210714000837140-57556b2c.png",ya="/MyBlog/assets/image-20210714000941256-f9c9b88b.png",fa="/MyBlog/assets/image-20210714001728017-0f7ef698.png",xa={},Ba=a("h1",{id:"springcloud01-🌸",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#springcloud01-🌸","aria-hidden":"true"},"#"),s(" SpringCloud01 🌸")],-1),Ma={class:"table-of-contents"},Ra=c('<h1 id="_1-认识微服务" tabindex="-1"><a class="header-anchor" href="#_1-认识微服务" aria-hidden="true">#</a> 1.认识微服务</h1><p>随着互联网行业的发展，对服务的要求也越来越高，服务架构也从单体架构逐渐演变为现在流行的微服务架构。这些架构之间有怎样的差别呢？</p><h2 id="_1-0-学习目标" tabindex="-1"><a class="header-anchor" href="#_1-0-学习目标" aria-hidden="true">#</a> 1.0.学习目标</h2><p>了解微服务架构的优缺点</p><h2 id="_1-1-单体架构" tabindex="-1"><a class="header-anchor" href="#_1-1-单体架构" aria-hidden="true">#</a> 1.1.单体架构</h2><p><strong>单体架构</strong>：将业务的所有功能集中在一个项目中开发，打成一个包部署。</p><p><img src="'+d+'" alt="image-20210713202807818"></p><p>单体架构的优缺点如下：</p><p><strong>优点：</strong></p><ul><li>架构简单</li><li>部署成本低</li></ul><p><strong>缺点：</strong></p><ul><li>耦合度高（维护困难、升级困难）</li></ul><h2 id="_1-2-分布式架构" tabindex="-1"><a class="header-anchor" href="#_1-2-分布式架构" aria-hidden="true">#</a> 1.2.分布式架构</h2><p><strong>分布式架构</strong>：根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。</p><p><img src="'+g+'" alt="image-20210713203124797"></p><p>分布式架构的优缺点：</p><p><strong>优点：</strong></p><ul><li>降低服务耦合</li><li>有利于服务升级和拓展</li></ul><p><strong>缺点：</strong></p><ul><li>服务调用关系错综复杂</li></ul><p>分布式架构虽然降低了服务耦合，但是服务拆分时也有很多问题需要思考：</p><ul><li>服务拆分的粒度如何界定？</li><li>服务之间如何调用？</li><li>服务的调用关系如何管理？</li></ul><p>人们需要制定一套行之有效的标准来约束分布式架构。</p><h2 id="_1-3-微服务" tabindex="-1"><a class="header-anchor" href="#_1-3-微服务" aria-hidden="true">#</a> 1.3.微服务</h2><p>微服务的架构特征：</p><ul><li>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责</li><li>自治：团队独立、技术独立、数据独立，独立部署和交付</li><li>面向服务：服务提供统一标准的接口，与语言和技术无关</li><li>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题</li></ul><p><img src="'+m+'" alt="image-20210713203753373"></p><p>微服务的上述特性其实是在给分布式架构制定一个标准，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。</p><p>因此，可以认为<strong>微服务</strong>是一种经过良好架构设计的<strong>分布式架构方案</strong> 。</p><p>但方案该怎么落地？选用什么样的技术栈？全球的互联网公司都在积极尝试自己的微服务落地方案。</p><p>其中在 Java 领域最引人注目的就是 SpringCloud 提供的方案了。</p><h2 id="_1-4-springcloud" tabindex="-1"><a class="header-anchor" href="#_1-4-springcloud" aria-hidden="true">#</a> 1.4.SpringCloud</h2><p>SpringCloud 是目前国内使用最广泛的微服务框架。官网地址：https://spring.io/projects/spring-cloud。</p><p>SpringCloud 集成了各种微服务功能组件，并基于 SpringBoot 实现了这些组件的自动装配，从而提供了良好的开箱即用体验。</p><p>其中常见的组件包括：</p><p><img src="'+k+'" alt="image-20210713204155887"></p><p>另外，SpringCloud 底层是依赖于 SpringBoot 的，并且有版本的兼容关系，如下：</p><p><img src="'+v+'" alt="image-20210713205003790"></p><p>我们课堂学习的版本是 Hoxton.SR10，因此对应的 SpringBoot 版本是 2.3.x 版本。</p><h2 id="_1-5-总结" tabindex="-1"><a class="header-anchor" href="#_1-5-总结" aria-hidden="true">#</a> 1.5.总结</h2><ul><li><p>单体架构：简单方便，高度耦合，扩展性差，适合小型项目。例如：学生管理系统</p></li><li><p>分布式架构：松耦合，扩展性好，但架构复杂，难度大。适合大型互联网项目，例如：京东、淘宝</p></li><li><p>微服务：一种良好的分布式架构方案</p><p>① 优点：拆分粒度更小、服务更独立、耦合度更低</p><p>② 缺点：架构非常复杂，运维、监控、部署难度提高</p></li><li><p>SpringCloud 是微服务架构的一站式解决方案，集成了各种优秀微服务功能组件</p></li></ul><h1 id="_2-服务拆分和远程调用" tabindex="-1"><a class="header-anchor" href="#_2-服务拆分和远程调用" aria-hidden="true">#</a> 2.服务拆分和远程调用</h1><p>任何分布式架构都离不开服务的拆分，微服务也是一样。</p><h2 id="_2-1-服务拆分原则" tabindex="-1"><a class="header-anchor" href="#_2-1-服务拆分原则" aria-hidden="true">#</a> 2.1.服务拆分原则</h2><p>这里我总结了微服务拆分时的几个原则：</p><ul><li>不同微服务，不要重复开发相同业务</li><li>微服务数据独立，不要访问其它微服务的数据库</li><li>微服务可以将自己的业务暴露为接口，供其它微服务调用</li></ul><p><img src="'+h+'" alt="image-20210713210800950"></p><h2 id="_2-2-服务拆分示例" tabindex="-1"><a class="header-anchor" href="#_2-2-服务拆分示例" aria-hidden="true">#</a> 2.2.服务拆分示例</h2><p>以课前资料中的微服务 cloud-demo 为例，其结构如下：</p><p><img src="'+_+'" alt="image-20210713211009593"></p><p>cloud-demo：父工程，管理依赖</p><ul><li>order-service：订单微服务，负责订单相关业务</li><li>user-service：用户微服务，负责用户相关业务</li></ul><p>要求：</p><ul><li>订单微服务和用户微服务都必须有各自的数据库，相互独立</li><li>订单服务和用户服务都对外暴露 Restful 的接口</li><li>订单服务如果需要查询用户信息，只能调用用户服务的 Restful 接口，不能查询用户数据库</li></ul><h3 id="_2-2-1-导入-sql-语句" tabindex="-1"><a class="header-anchor" href="#_2-2-1-导入-sql-语句" aria-hidden="true">#</a> 2.2.1.导入 Sql 语句</h3><p>首先，将课前资料提供的<code>cloud-order.sql</code>和<code>cloud-user.sql</code>导入到 mysql 中：</p><p><img src="'+b+'" alt="image-20210713211417049"></p><p>cloud-user 表中初始数据如下：</p><p><img src="'+y+'" alt="image-20210713211550169"></p><p>cloud-order 表中初始数据如下：</p><p><img src="'+f+'" alt="image-20210713211657319"></p><p>cloud-order 表中持有 cloud-user 表中的 id 字段。</p><h3 id="_2-2-2-导入-demo-工程" tabindex="-1"><a class="header-anchor" href="#_2-2-2-导入-demo-工程" aria-hidden="true">#</a> 2.2.2.导入 demo 工程</h3><p>用 IDEA 导入课前资料提供的 Demo：</p><p><img src="'+x+'" alt="image-20210713211814094"></p><p>项目结构如下：</p><p><img src="'+B+'" alt="image-20210713212656887"></p><p>导入后，会在 IDEA 右下角出现弹窗：</p><p><img src="'+M+'" alt="image-20210713212349272"></p><p>点击弹窗，然后按下图选择：</p><p><img src="'+R+'" alt="image-20210713212336185"></p><p>会出现这样的菜单：</p><p><img src="'+S+'" alt="image-20210713212513324"></p><p>配置下项目使用的 JDK：</p><p><img src="'+I+'" alt="image-20210713220736408"></p><h2 id="_2-3-实现远程调用案例" tabindex="-1"><a class="header-anchor" href="#_2-3-实现远程调用案例" aria-hidden="true">#</a> 2.3.实现远程调用案例</h2><p>在 order-service 服务中，有一个根据 id 查询订单的接口：</p><p><img src="'+w+'" alt="image-20210713212749575"></p><p>根据 id 查询订单，返回值是 Order 对象，如图：</p><p><img src="'+A+'" alt="image-20210713212901725"></p><p>其中的 user 为 null</p><p>在 user-service 中有一个根据 id 查询用户的接口：</p><p><img src="'+C+'" alt="image-20210713213146089"></p><p>查询的结果如图：</p><p><img src="'+N+'" alt="image-20210713213213075"></p><h3 id="_2-3-1-案例需求" tabindex="-1"><a class="header-anchor" href="#_2-3-1-案例需求" aria-hidden="true">#</a> 2.3.1.案例需求：</h3><p>修改 order-service 中的根据 id 查询订单业务，要求在查询订单的同时，根据订单中包含的 userId 查询出用户信息，一起返回。</p><p><img src="'+E+`" alt="image-20210713213312278"></p><p>因此，我们需要在 order-service 中 向 user-service 发起一个 http 的请求，调用 http://localhost:8081/user/{userId}这个接口。</p><p>大概的步骤是这样的：</p><ul><li>注册一个 RestTemplate 的实例到 Spring 容器</li><li>修改 order-service 服务中的 OrderService 类中的 queryOrderById 方法，根据 Order 对象中的 userId 查询 User</li><li>将查询的 User 填充到 Order 对象，一起返回</li></ul><h3 id="_2-3-2-注册-resttemplate" tabindex="-1"><a class="header-anchor" href="#_2-3-2-注册-resttemplate" aria-hidden="true">#</a> 2.3.2.注册 RestTemplate</h3><p>首先，我们在 order-service 服务中的 OrderApplication 启动类中，注册 RestTemplate 实例：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>order</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>mybatis<span class="token punctuation">.</span>spring<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">MapperScan</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span></span><span class="token class-name">SpringApplication</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span></span><span class="token class-name">SpringBootApplication</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Bean</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>client<span class="token punctuation">.</span></span><span class="token class-name">RestTemplate</span></span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@MapperScan</span><span class="token punctuation">(</span><span class="token string">&quot;cn.itcast.order.mapper&quot;</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@SpringBootApplication</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderApplication</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">OrderApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">RestTemplate</span> <span class="token function">restTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RestTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-3-3-实现远程调用" tabindex="-1"><a class="header-anchor" href="#_2-3-3-实现远程调用" aria-hidden="true">#</a> 2.3.3.实现远程调用</h3><p>修改 order-service 服务中的 cn.itcast.order.service 包下的 OrderService 类中的 queryOrderById 方法：</p><p><img src="`+q+'" alt="image-20210713213959569"></p><h2 id="_2-4-提供者与消费者" tabindex="-1"><a class="header-anchor" href="#_2-4-提供者与消费者" aria-hidden="true">#</a> 2.4.提供者与消费者</h2><p>在服务调用关系中，会有两个不同的角色：</p><p><strong>服务提供者</strong>：一次业务中，被其它微服务调用的服务。（提供接口给其它微服务）</p><p><strong>服务消费者</strong>：一次业务中，调用其它微服务的服务。（调用其它微服务提供的接口）</p><p><img src="'+L+'" alt="image-20210713214404481"></p><p>但是，服务提供者与服务消费者的角色并不是绝对的，而是相对于业务而言。</p><p>如果服务 A 调用了服务 B，而服务 B 又调用了服务 C，服务 B 的角色是什么？</p><ul><li>对于 A 调用 B 的业务而言：A 是服务消费者，B 是服务提供者</li><li>对于 B 调用 C 的业务而言：B 是服务消费者，C 是服务提供者</li></ul><p>因此，服务 B 既可以是服务提供者，也可以是服务消费者。</p><h1 id="_3-eureka-注册中心" tabindex="-1"><a class="header-anchor" href="#_3-eureka-注册中心" aria-hidden="true">#</a> 3.Eureka 注册中心</h1><p>假如我们的服务提供者 user-service 部署了多个实例，如图：</p><p><img src="'+O+'" alt="image-20210713214925388"></p><p>大家思考几个问题：</p><ul><li>order-service 在发起远程调用的时候，该如何得知 user-service 实例的 ip 地址和端口？</li><li>有多个 user-service 实例地址，order-service 调用时该如何选择？</li><li>order-service 如何得知某个 user-service 实例是否依然健康，是不是已经宕机？</li></ul><h2 id="_3-1-eureka-的结构和作用" tabindex="-1"><a class="header-anchor" href="#_3-1-eureka-的结构和作用" aria-hidden="true">#</a> 3.1.Eureka 的结构和作用</h2><p>这些问题都需要利用 SpringCloud 中的注册中心来解决，其中最广为人知的注册中心就是 Eureka，其结构如下：</p><p><img src="'+T+'" alt="image-20210713220104956"></p><p>回答之前的各个问题。</p><p>问题 1：order-service 如何得知 user-service 实例地址？</p><p>获取地址信息的流程如下：</p><ul><li>user-service 服务实例启动后，将自己的信息注册到 eureka-server（Eureka 服务端）。这个叫服务注册</li><li>eureka-server 保存服务名称到服务实例地址列表的映射关系</li><li>order-service 根据服务名称，拉取实例地址列表。这个叫服务发现或服务拉取</li></ul><p>问题 2：order-service 如何从多个 user-service 实例中选择具体的实例？</p><ul><li>order-service 从实例列表中利用负载均衡算法选中一个实例地址</li><li>向该实例地址发起远程调用</li></ul><p>问题 3：order-service 如何得知某个 user-service 实例是否依然健康，是不是已经宕机？</p><ul><li>user-service 会每隔一段时间（默认 30 秒）向 eureka-server 发起请求，报告自己状态，称为心跳</li><li>当超过一定时间没有发送心跳时，eureka-server 会认为微服务实例故障，将该实例从服务列表中剔除</li><li>order-service 拉取服务时，就能将故障实例排除了</li></ul><blockquote><p>注意：一个微服务，既可以是服务提供者，又可以是服务消费者，因此 eureka 将服务注册、服务发现等功能统一封装到了 eureka-client 端</p></blockquote><p>因此，接下来我们动手实践的步骤包括：</p><p><img src="'+Z+'" alt="image-20210713220509769"></p><h2 id="_3-2-搭建-eureka-server" tabindex="-1"><a class="header-anchor" href="#_3-2-搭建-eureka-server" aria-hidden="true">#</a> 3.2.搭建 eureka-server</h2><p>首先大家注册中心服务端：eureka-server，这必须是一个独立的微服务</p><h3 id="_3-2-1-创建-eureka-server-服务" tabindex="-1"><a class="header-anchor" href="#_3-2-1-创建-eureka-server-服务" aria-hidden="true">#</a> 3.2.1.创建 eureka-server 服务</h3><p>在 cloud-demo 父工程下，创建一个子模块：</p><p><img src="'+j+'" alt="image-20210713220605881"></p><p>填写模块信息：</p><p><img src="'+D+'" alt="image-20210713220857396"></p><p>然后填写服务信息：</p><p><img src="'+H+`" alt="image-20210713221339022"></p><h3 id="_3-2-2-引入-eureka-依赖" tabindex="-1"><a class="header-anchor" href="#_3-2-2-引入-eureka-依赖" aria-hidden="true">#</a> 3.2.2.引入 eureka 依赖</h3><p>引入 SpringCloud 为 eureka 提供的 starter 依赖：</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-netflix-eureka-server<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-2-3-编写启动类" tabindex="-1"><a class="header-anchor" href="#_3-2-3-编写启动类" aria-hidden="true">#</a> 3.2.3.编写启动类</h3><p>给 eureka-server 服务编写一个启动类，一定要添加一个@EnableEurekaServer 注解，开启 eureka 的注册中心功能：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>eureka</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span></span><span class="token class-name">SpringApplication</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span></span><span class="token class-name">SpringBootApplication</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cloud<span class="token punctuation">.</span>netflix<span class="token punctuation">.</span>eureka<span class="token punctuation">.</span>server<span class="token punctuation">.</span></span><span class="token class-name">EnableEurekaServer</span></span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@SpringBootApplication</span>
<span class="token annotation punctuation">@EnableEurekaServer</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EurekaApplication</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">EurekaApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-2-4-编写配置文件" tabindex="-1"><a class="header-anchor" href="#_3-2-4-编写配置文件" aria-hidden="true">#</a> 3.2.4.编写配置文件</h3><p>编写一个 application.yml 文件，内容如下：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">server</span><span class="token punctuation">:</span>
  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">10086</span>
<span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">application</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> eureka<span class="token punctuation">-</span>server
<span class="token key atrule">eureka</span><span class="token punctuation">:</span>
  <span class="token key atrule">client</span><span class="token punctuation">:</span>
    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>
      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//127.0.0.1<span class="token punctuation">:</span>10086/eureka
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-2-5-启动服务" tabindex="-1"><a class="header-anchor" href="#_3-2-5-启动服务" aria-hidden="true">#</a> 3.2.5.启动服务</h3><p>启动微服务，然后在浏览器访问：http://127.0.0.1:10086</p><p>看到下面结果应该是成功了：</p><p><img src="`+U+`" alt="image-20210713222157190"></p><h2 id="_3-3-服务注册" tabindex="-1"><a class="header-anchor" href="#_3-3-服务注册" aria-hidden="true">#</a> 3.3.服务注册</h2><p>下面，我们将 user-service 注册到 eureka-server 中去。</p><h3 id="_1-引入依赖" tabindex="-1"><a class="header-anchor" href="#_1-引入依赖" aria-hidden="true">#</a> 1）引入依赖</h3><p>在 user-service 的 pom 文件中，引入下面的 eureka-client 依赖：</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-netflix-eureka-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-配置文件" tabindex="-1"><a class="header-anchor" href="#_2-配置文件" aria-hidden="true">#</a> 2）配置文件</h3><p>在 user-service 中，修改 application.yml 文件，添加服务名称、eureka 地址：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">application</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> userservice
<span class="token key atrule">eureka</span><span class="token punctuation">:</span>
  <span class="token key atrule">client</span><span class="token punctuation">:</span>
    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>
      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//127.0.0.1<span class="token punctuation">:</span>10086/eureka
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-启动多个-user-service-实例" tabindex="-1"><a class="header-anchor" href="#_3-启动多个-user-service-实例" aria-hidden="true">#</a> 3）启动多个 user-service 实例</h3><p>为了演示一个服务有多个实例的场景，我们添加一个 SpringBoot 的启动配置，再启动一个 user-service。</p><p>首先，复制原来的 user-service 启动配置：</p><p><img src="`+F+'" alt="image-20210713222656562"></p><p>然后，在弹出的窗口中，填写信息：</p><p><img src="'+V+'" alt="image-20210713222757702"></p><p>现在，SpringBoot 窗口会出现两个 user-service 启动配置：</p><p><img src="'+P+'" alt="image-20210713222841951"></p><p>不过，第一个是 8081 端口，第二个是 8082 端口。</p><p>启动两个 user-service 实例：</p><p><img src="'+J+'" alt="image-20210713223041491"></p><p>查看 eureka-server 管理页面：</p><p><img src="'+K+`" alt="image-20210713223150650"></p><h2 id="_3-4-服务发现" tabindex="-1"><a class="header-anchor" href="#_3-4-服务发现" aria-hidden="true">#</a> 3.4.服务发现</h2><p>下面，我们将 order-service 的逻辑修改：向 eureka-server 拉取 user-service 的信息，实现服务发现。</p><h3 id="_1-引入依赖-1" tabindex="-1"><a class="header-anchor" href="#_1-引入依赖-1" aria-hidden="true">#</a> 1）引入依赖</h3><p>之前说过，服务发现、服务注册统一都封装在 eureka-client 依赖，因此这一步与服务注册时一致。</p><p>在 order-service 的 pom 文件中，引入下面的 eureka-client 依赖：</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-netflix-eureka-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-配置文件-1" tabindex="-1"><a class="header-anchor" href="#_2-配置文件-1" aria-hidden="true">#</a> 2）配置文件</h3><p>服务发现也需要知道 eureka 地址，因此第二步与服务注册一致，都是配置 eureka 信息：</p><p>在 order-service 中，修改 application.yml 文件，添加服务名称、eureka 地址：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">application</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> orderservice
<span class="token key atrule">eureka</span><span class="token punctuation">:</span>
  <span class="token key atrule">client</span><span class="token punctuation">:</span>
    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>
      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//127.0.0.1<span class="token punctuation">:</span>10086/eureka
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-服务拉取和负载均衡" tabindex="-1"><a class="header-anchor" href="#_3-服务拉取和负载均衡" aria-hidden="true">#</a> 3）服务拉取和负载均衡</h3><p>最后，我们要去 eureka-server 中拉取 user-service 服务的实例列表，并且实现负载均衡。</p><p>不过这些动作不用我们去做，只需要添加一些注解即可。</p><p>在 order-service 的 OrderApplication 中，给 RestTemplate 这个 Bean 添加一个@LoadBalanced 注解：</p><p><img src="`+W+'" alt="image-20210713224049419"></p><p>修改 order-service 服务中的 cn.itcast.order.service 包下的 OrderService 类中的 queryOrderById 方法。修改访问的 url 路径，用服务名代替 ip、端口：</p><p><img src="'+z+'" alt="image-20210713224245731"></p><p>spring 会自动帮助我们从 eureka-server 端，根据 userservice 这个服务名称，获取实例列表，而后完成负载均衡。</p><h1 id="_4-ribbon-负载均衡" tabindex="-1"><a class="header-anchor" href="#_4-ribbon-负载均衡" aria-hidden="true">#</a> 4.Ribbon 负载均衡</h1><p>上一节中，我们添加了@LoadBalanced 注解，即可实现负载均衡功能，这是什么原理呢？</p><h2 id="_4-1-负载均衡原理" tabindex="-1"><a class="header-anchor" href="#_4-1-负载均衡原理" aria-hidden="true">#</a> 4.1.负载均衡原理</h2><p>SpringCloud 底层其实是利用了一个名为 Ribbon 的组件，来实现负载均衡功能的。</p><p><img src="'+G+'" alt="image-20210713224517686"></p><p>那么我们发出的请求明明是 http://userservice/user/1，怎么变成了 http://localhost:8081 的呢？</p><h2 id="_4-2-源码跟踪" tabindex="-1"><a class="header-anchor" href="#_4-2-源码跟踪" aria-hidden="true">#</a> 4.2.源码跟踪</h2><p>为什么我们只输入了 service 名称就可以访问了呢？之前还要获取 ip 和端口。</p><p>显然有人帮我们根据 service 名称，获取到了服务实例的 ip 和端口。它就是<code>LoadBalancerInterceptor</code>，这个类会在对 RestTemplate 的请求进行拦截，然后从 Eureka 根据服务 id 获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务 id。</p><p>我们进行源码跟踪：</p><h3 id="_1-loadbalancerintercepor" tabindex="-1"><a class="header-anchor" href="#_1-loadbalancerintercepor" aria-hidden="true">#</a> 1）LoadBalancerIntercepor</h3><p><img src="'+Q+'" alt="1525620483637"></p><p>可以看到这里的 intercept 方法，拦截了用户的 HttpRequest 请求，然后做了几件事：</p><ul><li><code>request.getURI()</code>：获取请求 uri，本例中就是 http://user-service/user/8</li><li><code>originalUri.getHost()</code>：获取 uri 路径的主机名，其实就是服务 id，<code>user-service</code></li><li><code>this.loadBalancer.execute()</code>：处理服务 id，和用户请求。</li></ul><p>这里的<code>this.loadBalancer</code>是<code>LoadBalancerClient</code>类型，我们继续跟入。</p><h3 id="_2-loadbalancerclient" tabindex="-1"><a class="header-anchor" href="#_2-loadbalancerclient" aria-hidden="true">#</a> 2）LoadBalancerClient</h3><p>继续跟入 execute 方法：</p><p><img src="'+X+'" alt="1525620787090"></p><p>代码是这样的：</p><ul><li>getLoadBalancer(serviceId)：根据服务 id 获取 ILoadBalancer，而 ILoadBalancer 会拿着服务 id 去 eureka 中获取服务列表并保存起来。</li><li>getServer(loadBalancer)：利用内置的负载均衡算法，从服务列表中选择一个。本例中，可以看到获取了 8082 端口的服务</li></ul><p>放行后，再次访问并跟踪，发现获取的是 8081：</p><p><img src="'+i+'" alt="1525620835911"></p><p>果然实现了负载均衡。</p><h3 id="_3-负载均衡策略-irule" tabindex="-1"><a class="header-anchor" href="#_3-负载均衡策略-irule" aria-hidden="true">#</a> 3）负载均衡策略 IRule</h3><p>在刚才的代码中，可以看到获取服务使通过一个<code>getServer</code>方法来做负载均衡:</p><p><img src="'+i+'" alt="1525620835911"></p><p>我们继续跟入：</p><p><img src="'+Y+'" alt="1544361421671"></p><p>继续跟踪源码 chooseServer 方法，发现这么一段代码：</p><p><img src="'+$+'" alt="1525622652849"></p><p>我们看看这个 rule 是谁：</p><p><img src="'+aa+'" alt="1525622699666"></p><p>这里的 rule 默认值是一个<code>RoundRobinRule</code>，看类的介绍：</p><p><img src="'+sa+'" alt="1525622754316"></p><p>这不就是轮询的意思嘛。</p><p>到这里，整个负载均衡的流程我们就清楚了。</p><h3 id="_4-总结" tabindex="-1"><a class="header-anchor" href="#_4-总结" aria-hidden="true">#</a> 4）总结</h3><p>SpringCloudRibbon 的底层采用了一个拦截器，拦截了 RestTemplate 发出的请求，对地址做了修改。用一幅图来总结一下：</p><p><img src="'+na+'" alt="image-20210713224724673"></p><p>基本流程如下：</p><ul><li>拦截我们的 RestTemplate 请求 http://userservice/user/1</li><li>RibbonLoadBalancerClient 会从请求 url 中获取服务名称，也就是 user-service</li><li>DynamicServerListLoadBalancer 根据 user-service 到 eureka 拉取服务列表</li><li>eureka 返回列表，localhost:8081、localhost:8082</li><li>IRule 利用内置负载均衡规则，从列表中选择一个，例如 localhost:8081</li><li>RibbonLoadBalancerClient 修改请求地址，用 localhost:8081 替代 userservice，得到 http://localhost:8081/user/1，发起真实请求</li></ul><h2 id="_4-3-负载均衡策略" tabindex="-1"><a class="header-anchor" href="#_4-3-负载均衡策略" aria-hidden="true">#</a> 4.3.负载均衡策略</h2><h3 id="_4-3-1-负载均衡策略" tabindex="-1"><a class="header-anchor" href="#_4-3-1-负载均衡策略" aria-hidden="true">#</a> 4.3.1.负载均衡策略</h3><p>负载均衡的规则都定义在 IRule 接口中，而 IRule 有很多不同的实现类：</p><p><img src="'+ea+`" alt="image-20210713225653000"></p><p>不同规则的含义如下：</p><table><thead><tr><th><strong>内置负载均衡规则类</strong></th><th><strong>规则描述</strong></th></tr></thead><tbody><tr><td>RoundRobinRule</td><td>简单轮询服务列表来选择服务器。它是 Ribbon 默认的负载均衡规则。</td></tr><tr><td>AvailabilityFilteringRule</td><td>对以下两种服务器进行忽略： （1）在默认情况下，这台服务器如果 3 次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续 30 秒，如果再次连接失败，短路的持续时间就会几何级地增加。 （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了 AvailabilityFilteringRule 规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的<code>&lt;clientName&gt;</code>.<code>&lt;clientConfigNameSpace&gt;</code>.ActiveConnectionsLimit 属性进行配置。</td></tr><tr><td>WeightedResponseTimeRule</td><td>为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td></tr><tr><td><strong>ZoneAvoidanceRule</strong></td><td>以区域可用的服务器为基础进行服务器的选择。使用 Zone 对服务器进行分类，这个 Zone 可以理解为一个机房、一个机架等。而后再对 Zone 内的多个服务做轮询。</td></tr><tr><td>BestAvailableRule</td><td>忽略那些短路的服务器，并选择并发数较低的服务器。</td></tr><tr><td>RandomRule</td><td>随机选择一个可用的服务器。</td></tr><tr><td>RetryRule</td><td>重试机制的选择逻辑</td></tr></tbody></table><p>默认的实现就是 ZoneAvoidanceRule，是一种轮询方案</p><h3 id="_4-3-2-自定义负载均衡策略" tabindex="-1"><a class="header-anchor" href="#_4-3-2-自定义负载均衡策略" aria-hidden="true">#</a> 4.3.2.自定义负载均衡策略</h3><p>通过定义 IRule 实现可以修改负载均衡规则，有两种方式：</p><ol><li>代码方式：在 order-service 中的 OrderApplication 类中，定义一个新的 IRule：</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Bean</span>
<span class="token keyword">public</span> <span class="token class-name">IRule</span> <span class="token function">randomRule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RandomRule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>配置文件方式：在 order-service 的 application.yml 文件中，添加新的配置也可以修改规则：</li></ol><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">userservice</span><span class="token punctuation">:</span> <span class="token comment"># 给某个微服务配置负载均衡规则，这里是userservice服务</span>
  <span class="token key atrule">ribbon</span><span class="token punctuation">:</span>
    <span class="token key atrule">NFLoadBalancerRuleClassName</span><span class="token punctuation">:</span> com.netflix.loadbalancer.RandomRule <span class="token comment"># 负载均衡规则</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><strong>注意</strong>，一般用默认的负载均衡规则，不做修改。</p></blockquote><h2 id="_4-4-饥饿加载" tabindex="-1"><a class="header-anchor" href="#_4-4-饥饿加载" aria-hidden="true">#</a> 4.4.饥饿加载</h2><p>Ribbon 默认是采用懒加载，即第一次访问时才会去创建 LoadBalanceClient，请求时间(请求 eurekaClient 列表)会很长。</p><p>而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">ribbon</span><span class="token punctuation">:</span>
  <span class="token key atrule">eager-load</span><span class="token punctuation">:</span>
    <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
    <span class="token key atrule">clients</span><span class="token punctuation">:</span> userservice
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="_5-nacos-注册中心" tabindex="-1"><a class="header-anchor" href="#_5-nacos-注册中心" aria-hidden="true">#</a> 5.Nacos 注册中心</h1><p>国内公司一般都推崇阿里巴巴的技术，比如注册中心，SpringCloudAlibaba 也推出了一个名为 Nacos 的注册中心。</p><h2 id="_5-1-认识和安装-nacos" tabindex="-1"><a class="header-anchor" href="#_5-1-认识和安装-nacos" aria-hidden="true">#</a> 5.1.认识和安装 Nacos</h2>`,248),Sa={href:"https://nacos.io/",target:"_blank",rel:"noopener noreferrer"},Ia={href:"https://spring.io/projects/spring-cloud",target:"_blank",rel:"noopener noreferrer"},wa={href:"https://github.com/Netflix/eureka",target:"_blank",rel:"noopener noreferrer"},Aa=c('<p><img src="'+ta+`" alt="image-20210713230444308"></p><p>安装方式可以参考课前资料《Nacos 安装指南.md》</p><h2 id="_5-2-服务注册到-nacos" tabindex="-1"><a class="header-anchor" href="#_5-2-服务注册到-nacos" aria-hidden="true">#</a> 5.2.服务注册到 nacos</h2><p>Nacos 是 SpringCloudAlibaba 的组件，而 SpringCloudAlibaba 也遵循 SpringCloud 中定义的服务注册、服务发现规范。因此使用 Nacos 和使用 Eureka 对于微服务来说，并没有太大区别。</p><p>主要差异在于：</p><ul><li>依赖不同</li><li>服务地址不同</li></ul><h3 id="_1-引入依赖-2" tabindex="-1"><a class="header-anchor" href="#_1-引入依赖-2" aria-hidden="true">#</a> 1）引入依赖</h3><p>在 cloud-demo 父工程的 pom 文件中的<code>&lt;dependencyManagement&gt;</code>中引入 SpringCloudAlibaba 的依赖：</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-alibaba-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.2.6.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">&gt;</span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>import<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在 user-service 和 order-service 中的 pom 文件中引入 nacos-discovery 依赖：</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-alibaba-nacos-discovery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><strong>注意</strong>：不要忘了注释掉 eureka 的依赖。</p></blockquote><h3 id="_2-配置-nacos-地址" tabindex="-1"><a class="header-anchor" href="#_2-配置-nacos-地址" aria-hidden="true">#</a> 2）配置 nacos 地址</h3><p>在 user-service 和 order-service 的 application.yml 中添加 nacos 地址：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>
      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">8848</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><strong>注意</strong>：不要忘了注释掉 eureka 的地址</p></blockquote><h3 id="_3-重启" tabindex="-1"><a class="header-anchor" href="#_3-重启" aria-hidden="true">#</a> 3）重启</h3><p>重启微服务后，登录 nacos 管理页面，可以看到微服务信息：</p><p><img src="`+pa+'" alt="image-20210713231439607"></p><h2 id="_5-3-服务分级存储模型" tabindex="-1"><a class="header-anchor" href="#_5-3-服务分级存储模型" aria-hidden="true">#</a> 5.3.服务分级存储模型</h2><p>一个<strong>服务</strong>可以有多个<strong>实例</strong>，例如我们的 user-service，可以有:</p><ul><li>127.0.0.1:8081</li><li>127.0.0.1:8082</li><li>127.0.0.1:8083</li></ul><p>假如这些实例分布于全国各地的不同机房，例如：</p><ul><li>127.0.0.1:8081，在上海机房</li><li>127.0.0.1:8082，在上海机房</li><li>127.0.0.1:8083，在杭州机房</li></ul><p>Nacos 就将同一机房内的实例 划分为一个<strong>集群</strong>。</p><p>也就是说，user-service 是服务，一个服务可以包含多个集群，如杭州、上海，每个集群下可以有多个实例，形成分级模型，如图：</p><p><img src="'+la+'" alt="image-20210713232522531"></p><p>微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群。例如：</p><p><img src="'+ia+`" alt="image-20210713232658928"></p><p>杭州机房内的 order-service 应该优先访问同机房的 user-service。</p><h3 id="_5-3-1-给-user-service-配置集群" tabindex="-1"><a class="header-anchor" href="#_5-3-1-给-user-service-配置集群" aria-hidden="true">#</a> 5.3.1.给 user-service 配置集群</h3><p>修改 user-service 的 application.yml 文件，添加集群配置：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>
      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">8848</span>
      <span class="token key atrule">discovery</span><span class="token punctuation">:</span>
        <span class="token key atrule">cluster-name</span><span class="token punctuation">:</span> HZ <span class="token comment"># 集群名称</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重启两个 user-service 实例后，我们可以在 nacos 控制台看到下面结果：</p><p><img src="`+ca+`" alt="image-20210713232916215"></p><p>我们再次复制一个 user-service 启动配置，添加属性：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token parameter variable">-Dserver.port</span><span class="token operator">=</span><span class="token number">8083</span> -Dspring.cloud.nacos.discovery.cluster-name<span class="token operator">=</span>SH
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>配置如图所示：</p><p><img src="`+oa+'" alt="image-20210713233528982"></p><p>启动 UserApplication3 后再次查看 nacos 控制台：</p><p><img src="'+ra+`" alt="image-20210713233727923"></p><h3 id="_5-3-2-同集群优先的负载均衡" tabindex="-1"><a class="header-anchor" href="#_5-3-2-同集群优先的负载均衡" aria-hidden="true">#</a> 5.3.2.同集群优先的负载均衡</h3><p>默认的<code>ZoneAvoidanceRule</code>并不能实现根据同集群优先来实现负载均衡。</p><p>因此 Nacos 中提供了一个<code>NacosRule</code>的实现，可以优先从同集群中挑选实例。</p><p>1）给 order-service 配置集群信息</p><p>修改 order-service 的 application.yml 文件，添加集群配置：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>spring:
  cloud:
    nacos:
      server-addr: localhost:8848
      discovery:
        cluster-name: HZ <span class="token comment"># 集群名称</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2）修改负载均衡规则</p><p>修改 order-service 的 application.yml 文件，修改负载均衡规则：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">userservice</span><span class="token punctuation">:</span>
  <span class="token key atrule">ribbon</span><span class="token punctuation">:</span>
    <span class="token key atrule">NFLoadBalancerRuleClassName</span><span class="token punctuation">:</span> com.alibaba.cloud.nacos.ribbon.NacosRule <span class="token comment"># 负载均衡规则</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_5-4-权重配置" tabindex="-1"><a class="header-anchor" href="#_5-4-权重配置" aria-hidden="true">#</a> 5.4.权重配置</h2><p>实际部署中会出现这样的场景：</p><p>服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。</p><p>但默认情况下 NacosRule 是同集群内随机挑选，不会考虑机器的性能问题。</p><p>因此，Nacos 提供了权重配置来控制访问频率，权重越大则访问频率越高。</p><p>在 nacos 控制台，找到 user-service 的实例列表，点击编辑，即可修改权重：</p><p><img src="`+ua+'" alt="image-20210713235133225"></p><p>在弹出的编辑窗口，修改权重：</p><p><img src="'+da+'" alt="image-20210713235235219"></p><blockquote><p><strong>注意</strong>：如果权重修改为 0，则该实例永远不会被访问</p></blockquote><h2 id="_5-5-环境隔离" tabindex="-1"><a class="header-anchor" href="#_5-5-环境隔离" aria-hidden="true">#</a> 5.5.环境隔离</h2><p>Nacos 提供了 namespace 来实现环境隔离功能。</p><ul><li>nacos 中可以有多个 namespace</li><li>namespace 下可以有 group、service 等</li><li>不同 namespace 之间相互隔离，例如不同 namespace 的服务互相不可见</li></ul><p><img src="'+ga+'" alt="image-20210714000101516"></p><h3 id="_5-5-1-创建-namespace" tabindex="-1"><a class="header-anchor" href="#_5-5-1-创建-namespace" aria-hidden="true">#</a> 5.5.1.创建 namespace</h3><p>默认情况下，所有 service、data、group 都在同一个 namespace，名为 public：</p><p><img src="'+ma+'" alt="image-20210714000414781"></p><p>我们可以点击页面新增按钮，添加一个 namespace：</p><p><img src="'+ka+'" alt="image-20210714000440143"></p><p>然后，填写表单：</p><p><img src="'+va+'" alt="image-20210714000505928"></p><p>就能在页面看到一个新的 namespace：</p><p><img src="'+ha+`" alt="image-20210714000522913"></p><h3 id="_5-5-2-给微服务配置-namespace" tabindex="-1"><a class="header-anchor" href="#_5-5-2-给微服务配置-namespace" aria-hidden="true">#</a> 5.5.2.给微服务配置 namespace</h3><p>给微服务配置 namespace 只能通过修改配置来实现。</p><p>例如，修改 order-service 的 application.yml 文件：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>
      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">8848</span>
      <span class="token key atrule">discovery</span><span class="token punctuation">:</span>
        <span class="token key atrule">cluster-name</span><span class="token punctuation">:</span> HZ
        <span class="token key atrule">namespace</span><span class="token punctuation">:</span> 492a7d5d<span class="token punctuation">-</span>237b<span class="token punctuation">-</span>46a1<span class="token punctuation">-</span>a99a<span class="token punctuation">-</span>fa8e98e4b0f9 <span class="token comment"># 命名空间，填ID</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重启 order-service 后，访问控制台，可以看到下面的结果：</p><p><img src="`+_a+'" alt="image-20210714000830703"></p><p><img src="'+ba+'" alt="image-20210714000837140"></p><p>此时访问 order-service，因为 namespace 不同，会导致找不到 userservice，控制台会报错：</p><p><img src="'+ya+`" alt="image-20210714000941256"></p><h2 id="_5-6-nacos-与-eureka-的区别" tabindex="-1"><a class="header-anchor" href="#_5-6-nacos-与-eureka-的区别" aria-hidden="true">#</a> 5.6.Nacos 与 Eureka 的区别</h2><p>Nacos 的服务实例分为两种 l 类型：</p><ul><li><p>临时实例：如果实例宕机超过一定时间，会从服务列表剔除，默认的类型。</p></li><li><p>非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。</p></li></ul><p>配置一个服务实例为永久实例：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>
      <span class="token key atrule">discovery</span><span class="token punctuation">:</span>
        <span class="token key atrule">ephemeral</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 设置为非临时实例</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Nacos 和 Eureka 整体结构类似，服务注册、服务拉取、心跳等待，但是也存在一些差异：</p><p><img src="`+fa+'" alt="image-20210714001728017"></p><ul><li><p>Nacos 与 eureka 的共同点</p><ul><li>都支持服务注册和服务拉取</li><li>都支持服务提供者心跳方式做健康检测</li></ul></li><li><p>Nacos 与 Eureka 的区别</p><ul><li>Nacos 支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li><li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li><li>Nacos 支持服务列表变更的消息推送模式，服务列表更新更及时</li><li>Nacos 集群默认采用 AP 方式，当集群中存在非临时实例时，采用 CP 模式；Eureka 采用 AP 方式</li></ul></li></ul>',90);function Ca(Na,Ea){const e=l("router-link"),p=l("ExternalLinkIcon");return r(),u("div",null,[Ba,a("nav",Ma,[a("ul",null,[a("li",null,[n(e,{to:"#_1-0-学习目标"},{default:t(()=>[s("1.0.学习目标")]),_:1})]),a("li",null,[n(e,{to:"#_1-1-单体架构"},{default:t(()=>[s("1.1.单体架构")]),_:1})]),a("li",null,[n(e,{to:"#_1-2-分布式架构"},{default:t(()=>[s("1.2.分布式架构")]),_:1})]),a("li",null,[n(e,{to:"#_1-3-微服务"},{default:t(()=>[s("1.3.微服务")]),_:1})]),a("li",null,[n(e,{to:"#_1-4-springcloud"},{default:t(()=>[s("1.4.SpringCloud")]),_:1})]),a("li",null,[n(e,{to:"#_1-5-总结"},{default:t(()=>[s("1.5.总结")]),_:1})]),a("li",null,[n(e,{to:"#_2-1-服务拆分原则"},{default:t(()=>[s("2.1.服务拆分原则")]),_:1})]),a("li",null,[n(e,{to:"#_2-2-服务拆分示例"},{default:t(()=>[s("2.2.服务拆分示例")]),_:1}),a("ul",null,[a("li",null,[n(e,{to:"#_2-2-1-导入-sql-语句"},{default:t(()=>[s("2.2.1.导入 Sql 语句")]),_:1})]),a("li",null,[n(e,{to:"#_2-2-2-导入-demo-工程"},{default:t(()=>[s("2.2.2.导入 demo 工程")]),_:1})])])]),a("li",null,[n(e,{to:"#_2-3-实现远程调用案例"},{default:t(()=>[s("2.3.实现远程调用案例")]),_:1}),a("ul",null,[a("li",null,[n(e,{to:"#_2-3-1-案例需求"},{default:t(()=>[s("2.3.1.案例需求：")]),_:1})]),a("li",null,[n(e,{to:"#_2-3-2-注册-resttemplate"},{default:t(()=>[s("2.3.2.注册 RestTemplate")]),_:1})]),a("li",null,[n(e,{to:"#_2-3-3-实现远程调用"},{default:t(()=>[s("2.3.3.实现远程调用")]),_:1})])])]),a("li",null,[n(e,{to:"#_2-4-提供者与消费者"},{default:t(()=>[s("2.4.提供者与消费者")]),_:1})]),a("li",null,[n(e,{to:"#_3-1-eureka-的结构和作用"},{default:t(()=>[s("3.1.Eureka 的结构和作用")]),_:1})]),a("li",null,[n(e,{to:"#_3-2-搭建-eureka-server"},{default:t(()=>[s("3.2.搭建 eureka-server")]),_:1}),a("ul",null,[a("li",null,[n(e,{to:"#_3-2-1-创建-eureka-server-服务"},{default:t(()=>[s("3.2.1.创建 eureka-server 服务")]),_:1})]),a("li",null,[n(e,{to:"#_3-2-2-引入-eureka-依赖"},{default:t(()=>[s("3.2.2.引入 eureka 依赖")]),_:1})]),a("li",null,[n(e,{to:"#_3-2-3-编写启动类"},{default:t(()=>[s("3.2.3.编写启动类")]),_:1})]),a("li",null,[n(e,{to:"#_3-2-4-编写配置文件"},{default:t(()=>[s("3.2.4.编写配置文件")]),_:1})]),a("li",null,[n(e,{to:"#_3-2-5-启动服务"},{default:t(()=>[s("3.2.5.启动服务")]),_:1})])])]),a("li",null,[n(e,{to:"#_3-3-服务注册"},{default:t(()=>[s("3.3.服务注册")]),_:1}),a("ul",null,[a("li",null,[n(e,{to:"#_1-引入依赖"},{default:t(()=>[s("1）引入依赖")]),_:1})]),a("li",null,[n(e,{to:"#_2-配置文件"},{default:t(()=>[s("2）配置文件")]),_:1})]),a("li",null,[n(e,{to:"#_3-启动多个-user-service-实例"},{default:t(()=>[s("3）启动多个 user-service 实例")]),_:1})])])]),a("li",null,[n(e,{to:"#_3-4-服务发现"},{default:t(()=>[s("3.4.服务发现")]),_:1}),a("ul",null,[a("li",null,[n(e,{to:"#_1-引入依赖-1"},{default:t(()=>[s("1）引入依赖")]),_:1})]),a("li",null,[n(e,{to:"#_2-配置文件-1"},{default:t(()=>[s("2）配置文件")]),_:1})]),a("li",null,[n(e,{to:"#_3-服务拉取和负载均衡"},{default:t(()=>[s("3）服务拉取和负载均衡")]),_:1})])])]),a("li",null,[n(e,{to:"#_4-1-负载均衡原理"},{default:t(()=>[s("4.1.负载均衡原理")]),_:1})]),a("li",null,[n(e,{to:"#_4-2-源码跟踪"},{default:t(()=>[s("4.2.源码跟踪")]),_:1}),a("ul",null,[a("li",null,[n(e,{to:"#_1-loadbalancerintercepor"},{default:t(()=>[s("1）LoadBalancerIntercepor")]),_:1})]),a("li",null,[n(e,{to:"#_2-loadbalancerclient"},{default:t(()=>[s("2）LoadBalancerClient")]),_:1})]),a("li",null,[n(e,{to:"#_3-负载均衡策略-irule"},{default:t(()=>[s("3）负载均衡策略 IRule")]),_:1})]),a("li",null,[n(e,{to:"#_4-总结"},{default:t(()=>[s("4）总结")]),_:1})])])]),a("li",null,[n(e,{to:"#_4-3-负载均衡策略"},{default:t(()=>[s("4.3.负载均衡策略")]),_:1}),a("ul",null,[a("li",null,[n(e,{to:"#_4-3-1-负载均衡策略"},{default:t(()=>[s("4.3.1.负载均衡策略")]),_:1})]),a("li",null,[n(e,{to:"#_4-3-2-自定义负载均衡策略"},{default:t(()=>[s("4.3.2.自定义负载均衡策略")]),_:1})])])]),a("li",null,[n(e,{to:"#_4-4-饥饿加载"},{default:t(()=>[s("4.4.饥饿加载")]),_:1})]),a("li",null,[n(e,{to:"#_5-1-认识和安装-nacos"},{default:t(()=>[s("5.1.认识和安装 Nacos")]),_:1})]),a("li",null,[n(e,{to:"#_5-2-服务注册到-nacos"},{default:t(()=>[s("5.2.服务注册到 nacos")]),_:1}),a("ul",null,[a("li",null,[n(e,{to:"#_1-引入依赖-2"},{default:t(()=>[s("1）引入依赖")]),_:1})]),a("li",null,[n(e,{to:"#_2-配置-nacos-地址"},{default:t(()=>[s("2）配置 nacos 地址")]),_:1})]),a("li",null,[n(e,{to:"#_3-重启"},{default:t(()=>[s("3）重启")]),_:1})])])]),a("li",null,[n(e,{to:"#_5-3-服务分级存储模型"},{default:t(()=>[s("5.3.服务分级存储模型")]),_:1}),a("ul",null,[a("li",null,[n(e,{to:"#_5-3-1-给-user-service-配置集群"},{default:t(()=>[s("5.3.1.给 user-service 配置集群")]),_:1})]),a("li",null,[n(e,{to:"#_5-3-2-同集群优先的负载均衡"},{default:t(()=>[s("5.3.2.同集群优先的负载均衡")]),_:1})])])]),a("li",null,[n(e,{to:"#_5-4-权重配置"},{default:t(()=>[s("5.4.权重配置")]),_:1})]),a("li",null,[n(e,{to:"#_5-5-环境隔离"},{default:t(()=>[s("5.5.环境隔离")]),_:1}),a("ul",null,[a("li",null,[n(e,{to:"#_5-5-1-创建-namespace"},{default:t(()=>[s("5.5.1.创建 namespace")]),_:1})]),a("li",null,[n(e,{to:"#_5-5-2-给微服务配置-namespace"},{default:t(()=>[s("5.5.2.给微服务配置 namespace")]),_:1})])])]),a("li",null,[n(e,{to:"#_5-6-nacos-与-eureka-的区别"},{default:t(()=>[s("5.6.Nacos 与 Eureka 的区别")]),_:1})])])]),Ra,a("p",null,[a("a",Sa,[s("Nacos"),n(p)]),s("是阿里巴巴的产品，现在是"),a("a",Ia,[s("SpringCloud"),n(p)]),s("中的一个组件。相比"),a("a",wa,[s("Eureka"),n(p)]),s("功能更加丰富，在国内受欢迎程度较高。")]),Aa])}const La=o(xa,[["render",Ca],["__file","index.html.vue"]]);export{La as default};
